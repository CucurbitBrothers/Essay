<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.0 (460661)"/><meta name="author" content="1404001663@qq.com"/><meta name="created" content="2018-08-15 08:49:55 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="yinxiang.win32"/><meta name="updated" content="2018-09-16 12:34:56 +0000"/><title>31-C10K问题</title></head><body><div><ul><li><div><span style="font-size: 12pt;">&nbsp;&nbsp; .这个概念最早由 Dan Kegel 提出，简单来说就是：单机1万个并发连接（FTP服务）问题，也就是说如何突破单机性能极限，更优化的处理高并发问题，</span></div></li></ul><div><br/></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">本质：</span></div></li><ul><li><div><span style="font-size: 12pt;">本质上是操作系统的问题。对于Web1.0/2.0时代的操作系统而言， 传统的同步阻塞I/O模型都是一样的，并发10K和100的区别关键在于CPU。</span></div></li><li><div><span style="font-size: 12pt;">创建的进程线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质！</span></div></li><li><div><span style="font-size: 12pt;">关键就是尽可能减少这些CPU等核心计算资源消耗</span></div></li></ul><li><div><span style="font-size: 12pt;">解决思路：</span></div></li><ul><li><div><span style="font-size: 12pt;">每个进程/线程处理一个连接</span></div></li><ul><li><div><span style="font-size: 12pt;">资源占用过多，可扩展行差</span></div></li></ul><li><div><span style="font-size: 12pt;">每个进程/线程同时处理多个连接（IO多路复用）</span></div></li><ul><li><div><span style="font-size: 12pt;">解决方案：</span></div></li><ul><li><div><span style="font-size: 12pt;">select，poll，epoll（Linux独有），ICOP（Windows），libevent（跨平台）</span></div></li><ul><li><div><span style="font-size: 12pt;">epoll技术的编程模型就是异步非阻塞回调，也可以叫做Reactor，事件驱动，事件轮循（EventLoop）</span></div></li><li><div><span style="font-size: 12pt;">其实epoll 已经可以较好的处理 C10K 问题，但是如果要进一步的扩展，例如支持 10M 规模的并发连接，原有的技术就无能为力了</span></div></li></ul><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">协程（</span> <span style="background-color: rgb(255, 250, 165); font-size: 12pt; font-weight: bold;-evernote-highlight:true;">一种更轻量级的进程/线程</span><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">）</span></div></li><ul><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">本质是异步非阻塞技术</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">类似于同步阻塞，只不过同步阻塞是操作系统进行调度，而协程是自己内部进行调度</span></div></li><li><div><span style="font-size: 12pt;">协程的优点是它比系统线程开销小，缺点是如果其中一个协程中有密集计算，其他的协程就不运行了。操作系统进程的缺点是开销大，优点是无论代码怎么写，所有进程都可以并发运行。</span></div></li><ul><li><div><span style="font-size: 12pt;">实际上同步阻塞程序的性能并不差，它的效率很高，不会浪费资源。当进程发生阻塞后，操作系统会将它挂起，不会分配CPU。直到数据到达才会分配CPU。多进程只是开多了之后副作用太大，因为进程多了互相切换有开销。所以如果一个服务器程序只有1000左右的并发连接，同步阻塞模式是最好的。</span></div></li></ul></ul></ul></ul></ul><li><div><h2><span style="font-size: 12pt; font-weight: normal;">异步回调和协程</span></h2></div></li><ul><li><div><span style="font-size: 12pt; font-weight: normal;">协程虽然是用户态调度，实际上还是需要调度的，既然调度就会存在上下文切换。所以协程虽然比操作系统进程性能要好，但总还是有额外消耗的。而异步回调是没有切换开销的，它等同于顺序执行代码。所以异步回调程序的性能是要优于协程模型的。</span></div></li></ul></ul><div><br/></div><ul><li><div><span style="font-size: 12pt;">C10k</span></div></li><ul><li><div><span style="font-size: 12pt;">当同时连接数在10K左右时，传统模型就不再适用。实际上在效率测试报告的线程切换开销一节可以看到，超过1K后性能就差的一塌糊涂了。</span></div></li><li><div><span style="font-size: 12pt;">进程模型</span></div></li><ul><li><div><span style="font-size: 12pt;">在C10K的时候，启动和关闭这么多进程是不可接受的开销。事实上单纯的进程fork模型在C1K时就应当抛弃了。</span></div></li></ul><li><div><span style="font-size: 12pt;">线程模型</span></div></li><ul><li><div><span style="font-size: 12pt;">从任何测试都可以表明，线程模式比进程模式更耐久一些，性能更好。但是在面对C10K还是力不从心的。问题是，线程模式的问题出在哪里呢？</span></div></li></ul><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">协程模型</span></div></li><ul><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">比系统开销更小，可以很轻易的处理高并发访问</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);font-size: 12pt;-evernote-highlight:true;">gevent，自动切换上下文</span></div></li></ul><li><div><span style="font-size: 12pt;">回调模型（CPS模型）</span></div></li><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">在IO调用的时候，同时传入一个函数，作为返回函数。当IO结束时，调用传入的函数来处理下面的流程。</span></span></div></li><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">CPS模型：</span><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">把一切操作都当作了IO，无论干什么，结果要通过回调函数来返回</span></span></div></li></ul><li><div><span style="font-size: 12pt;">状态机模型</span></div></li><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">本质是每次重入（基本已经不用）</span></span></div></li></ul></ul></ul><div><br/></div></div><div><br/></div></body></html>