<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.0 (460661)"/><meta name="author" content="1404001663@qq.com"/><meta name="created" content="2018-08-14 13:49:15 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="yinxiang.win32"/><meta name="source-url" content="https://juejin.im/post/5b34b117f265da59a50b2fbe"/><meta name="updated" content="2020-04-28 15:00:53 +0000"/><title>11-垃圾回收（Garbage Collection）</title></head><body><div><div><div><span style="font-size: 12pt;">垃圾回收：</span></div><div><span style="font-size: 12pt;">    </span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">在计算机科学中是一种自动的</span><a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86" style="background-image: none; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(11, 0, 128); font-family: sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;" title="存储器管理">存储器管理</a><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为</span><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">垃圾回收。</span><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif;">垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。垃圾回收最早起源于</span><a href="https://zh.wikipedia.org/wiki/LISP" style="background-image: none; font-size: 12pt; color: rgb(11, 0, 128); font-family: sans-serif;" title="LISP">LISP</a><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif;">语言</span></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div><span style="font-size: 12pt; color: rgb(34, 34, 34); font-family: sans-serif;">Python的存储机理</span></div></li><ul><li><div><span style="min-height: 14pt;"><span style="font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">python采用的是引用计数机制为主，标记-清除，分代收集两种机制为辅的策略</span></span></div></li><li><div><span style="font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">底层实现借助于c语言的  malloc和 free</span></div></li></ul></ul><div><br/></div><div><br/></div></div><ul><li><div><span style="font-size: 12pt;">引用计数</span></div></li><ul><li><div><span style="font-size: 12pt;">每一个对象，都维护这一个指向该对象的引用的计数。</span></div></li><li><div><span style="font-size: 12pt;">当变量被绑定在一个对象上的时候，该变量的引用计数就是1，(还有另外一些情况也会导致变量引用计数的增加),</span></div></li><li><div><span style="font-size: 12pt;">系统会自动维护这些标签，并定时扫描，当某标签的引用计数变为0的时候，该对象就会被回收。</span></div></li><li><div><span style="font-size: 12pt;">但它不能处理</span><span style="min-height: 14pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">环形数据结构--也就是含有循环引用的数据结构。</span></div></li></ul><li><div><span style="font-family: &quot;Microsoft YaHei&quot;;">标记-清除</span></div></li><ul><li><div><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">标记清除就是用来解决循环引用的问题的，只有容器对象才会出现引用循环，比如列表、字典、类、元组。</span></div></li><li><div><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">标记-清除算法中，有两个集中营，一个是</span><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">root链表(root object)</span><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">，另外一个是</span><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">unreachable链表</span><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div></li><ul><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">python标记删除时通过l两个容器来完成的：死亡容器、存活容器。</span></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">标记删除第一步：对执行删除操作后的每个引用-1，此时c的引用为0，d的引用为0，把他们都放到死亡容器内。把那些引用仍然大于0的放到存活容器内。</span><br/></div></li></ul></ul><ul><ul><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;" /></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">标记删除第二步：遍历存活容器，查看是否有的存活容器引用了死亡容器内的对象，如果有就把该对象(注意是对象，比如0x7f94bb602f80，不是对象的引用)从死亡容器内取出，放到存活容器内。</span></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">由于c、d都没有对象引用他们了，所以经过这一步骤，他们还是在死亡组。</span></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;" /></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">标记删除第三步：将死亡组所有对象删除。</span></div></li><li><div><span style="color: rgb(8, 8, 8); --inversion-type-color: simple;">这样就完成了对从c、d的删除。</span></div></li></ul></ul><li><div><span style="font-size: 12pt; font-family: &quot;Microsoft YaHei&quot;;">分代收集</span></div></li><ul><li><div><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">垃圾回收=垃圾检测+释放</span><span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div></li><li><div><font style="font-size: 12pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(46, 46, 46); font-family: &quot;Microsoft YaHei&quot;, 宋体, &quot;Myriad Pro&quot;, Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。</span></font></div></li><ul><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(46, 46, 46); font-family: &quot;Microsoft YaHei&quot;, 宋体, &quot;Myriad Pro&quot;, Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率随对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。</span></font></span></div></li><ul><li><div><span style="font-size: 12pt; color: rgb(46, 46, 46); font-family: &quot;Microsoft YaHei&quot;;">弱代假说：</span><span style="min-height: 14pt; font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">年轻的对象通常死得也快，而老对象则很有可能存活更长的时间</span></div></li></ul><li><div><font style="font-size: 12pt;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(46, 46, 46); font-family: &quot;Microsoft YaHei&quot;, 宋体, &quot;Myriad Pro&quot;, Lato, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</span></font></div></li></ul></ul></ul><div><br/></div><ul><li><div><span style="font-size: 12pt; font-family: &quot;Microsoft YaHei&quot;;">内存池</span></div></li><ul><li><div><span style="font-size: 12pt;">-1，-2层主要由操作系统进行操作</span></div></li><li><div><span style="font-size: 12pt;">第0层是C中的malloc，free等内存分配和释放函数进行操作</span></div></li><li><div><span style="font-size: 12pt;">第1层和第2层是内存池，由Python的接口函数PyMem_Malloc函数实现，当对象小于256K时由该层直接分配内存，当释放后，重新回到内存池，并不会直接调用C的free</span></div></li><li><div><span style="font-size: 12pt;">第3层是最上层，也就是我们对Python对象的直接操作</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Microsoft YaHei&quot;;">小整数池</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: &quot;Microsoft YaHei&quot;;">小整数[-5,257)共用对象，常驻内存，在程序一开始就被预定义。</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Python 在运行期间会大量地执行 malloc 和 free 的操作，频繁地在用户态和核心态之间进行切</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">换，这将严重影响 Python 的执行效率。为了加速 Python 的执行效率，Python 引入了一个内存池</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">机制，用于管理对小块内存的申请和释放。</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">Python 内部默认的小块内存与大块内存的分界点定在 256 个字节，当申请的内存小于 256 字节</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">时，PyObject_Malloc 会在内存池中申请内存；当申请的内存大于 256 字节时，PyObject_Malloc 的</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">行为将蜕化为 malloc 的行为。当然，通过修改 Python 源代码，我们可以改变这个默认值，从而改</span></div><div><span style="font-family: Monaco; font-size: 9pt; color: rgb(51, 51, 51);">变 Python 的默认内存管理行为。</span></div></div><div><br/></div><ul><li><div><span style="font-size: 12pt;">gc模块</span></div></li><ul><li><div><span style="font-size: 12pt;">Python中的垃圾回收模块</span></div></li><li><div><span style="min-height: 14pt;"><span style="font-size: 12pt; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">gc模块提供一个接口给开发者设置垃圾回收的选项,主要功能就是解决循环引用</span></span></div></li></ul><li><div><span style="font-size: 16px; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">调优手段</span></div></li><ul><li><div><span style="font-size: 16px; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">手动垃圾回收</span></div></li><li><div><span style="font-size: 16px; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">调高垃圾回收阈值</span></div></li><li><div><span style="font-size: 16px; color: rgb(1, 1, 1); font-family: &quot;Microsoft YaHei&quot;;">避免循环引用（手动解除循环引用，使用弱引用）</span></div></li></ul></ul><div><br/></div></div><div><br/></div></body></html>