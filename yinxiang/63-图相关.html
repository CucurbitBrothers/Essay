<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.0 (460661)"/><meta name="author" content="南墙"/><meta name="created" content="2020-04-24 14:33:31 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-04-28 08:09:44 +0000"/><title>63-图相关</title></head><body><ol><li><div>首先有一个概念：回溯</div><div>　　回溯法(探索与回溯法)是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</div></li></ol><ul><li><div>深度优先算法：</div><div>（1）访问初始顶点v并标记顶点v已访问。</div><div>（2）查找顶点v的第一个邻接顶点w。</div><div>（3）若顶点v的邻接顶点w存在，则继续执行；否则回溯到v，再找v的另外一个未访问过的邻接点。</div><div>（4）若顶点w尚未被访问，则访问顶点w并标记顶点w为已访问。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">（5）继续查找顶点w的下一个邻接顶点wi，如果v取值wi转到步骤（3）。直到连通图中所有顶点全部访问过为止。
</span></div><div><img src="63-%E5%9B%BE%E7%9B%B8%E5%85%B3.resources/C8CFDCEF-D160-487B-8D6D-4C357F12E597.png" height="1550" width="1310"/></div><div><br/></div><div><br/></div></li><li><div>广度优先算法：</div><div>（1）顶点v入队列。</div><div>（2）当队列非空时则继续执行，否则算法结束。</div><div>（3）出队列取得队头顶点v；访问顶点v并标记顶点v已被访问。</div><div>（4）查找顶点v的第一个邻接顶点col。</div><div>（5）若v的邻接顶点col未被访问过的，则col入队列。</div><div>（6）继续查找顶点v的另一个新的邻接顶点col，转到步骤（5）。</div><div style="margin-top: 1em; margin-bottom: 1em;"><span style="-en-paragraph:true;">直到顶点v的所有未被访问过的邻接点处理完。转到步骤（2）。
</span></div><div><img src="63-%E5%9B%BE%E7%9B%B8%E5%85%B3.resources/7E00BEDF-A507-4DF1-BB8C-1007115617F8.png" height="1590" width="1380"/></div></li></ul><h4>代码实现
</h4><ul><li><div>图结构</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);-en-codeblock:true;"><div>class Graph:</div><div>    class Vertex:</div><div>        __slots__='_element'</div><div>        def __init__(self,x):</div><div>            self._element = x</div><div>        def element(self):</div><div>            return self._element</div><div>        def __hash__(self):</div><div>            return hash(id(self))</div><div>    class Edge:</div><div>        __slots__='_origin','_destination','_element'</div><div>        def __init__(self,u,v,x):</div><div>            self._origin =u</div><div>            self._destination=v</div><div>            self._element=x</div><div>        def endpoints(self): # 返回元组（u,v）</div><div>            return (self._origin,self._destination)</div><div>        def opposite(self,v):</div><div>            return self._destination if v is self._origin else self._origin</div><div>        def element(self):</div><div>            return self._element</div><div>        def __hash__(self):</div><div>            return hash(self._origin,self._destination)</div><div>            </div><div>    def __init__(self,directed=False):</div><div>        self._outgoing = {}</div><div>        self._incoming = {} if directed else self._outgoing # 只有在有向图的时候激活</div><div>    def is_directed(self):</div><div>        return self._incoming is not self._outgoing</div><div>    def vertex_count(self):</div><div>        return len(self._outgoing)</div><div>    def vertices(self):</div><div>        return self._outgoing.keys()</div><div>    def edge_count(self):</div><div>        total = sum(len(self._outgoing[v]) for v in self._outgoing)</div><div>        return total if self.is_directed() else total//2 # 有向图边是无向图的两倍</div><div>    def edges(self):</div><div>        result =set()</div><div>        for secondary_map in self._outgoing.values():</div><div>            result.update(secondary_map.values) # The A.update(B) adds elements from the set B to A.</div><div>        return result</div><div>    def get_edge(self,u,v):</div><div>        return self._outgoing[u].get(v)</div><div>    def degree(self,v,outgoing=True):</div><div>        adj = self._outgoing if outgoing else self._incoming</div><div>        return len(adj[v])</div><div>    def incident_edges(self,v,outgoing=True):</div><div>        adj=self._outgoing if outgoing else self._incoming</div><div>        for edge in adj[v].values():</div><div>            yield edge</div><div>    def insert_vertex(self,x=None):</div><div>        v=self.Vertex(x)</div><div>        self._outgoing[v]={}</div><div>        if self.is_directed():</div><div>            self._incoming[v]={}</div><div>        return v</div><div>    def insert_edge(self,u,v,x=None):</div><div>        e = self.Edge(u,v,x)</div><div>        self._outgoing[u][v]=e</div><div>        self._incoming[v][u]=e</div><div>* 深度遍历与广度遍历</div><div># 深度遍历</div><div>def DFS(g,u,discovered):</div><div>    for e in g.incident_edges(): # for every outgoing edge from u</div><div>        v= e.opposite(u)</div><div>        if v not in discovered:</div><div>            discovered[v]=e</div><div>            DFS(g,v,discovered)</div><div># 广度遍历</div><div>def BFS(g,s,discovered):</div><div>    level=[s]</div><div>    while len(level)&gt;0:</div><div>        next_level=[]</div><div>        for u in level:</div><div>            for e in g.incident_edges(u):</div><div>                v = e.opposite(u)</div><div>                if v not in discovered:</div><div>                    discovered[v]=e</div><div>                    next_level.append(v)</div><div>        level=next_level</div><div><div><br/></div></div></div><div><br/></div></body></html>