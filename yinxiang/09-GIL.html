<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.0 (460661)"/><meta name="author" content="1404001663@qq.com"/><meta name="created" content="2018-08-19 08:06:04 +0000"/><meta name="source" content="desktop.win"/><meta name="source-application" content="yinxiang.win32"/><meta name="updated" content="2020-04-25 13:50:25 +0000"/><title>09-GIL</title></head><body><div><div><span style="font-family: &quot;Adobe 宋体 Std L&quot;; font-size: 14pt;">GIL的全称是Global Interpreter Lock（全局解释器锁）</span></div><div><font face="Adobe 宋体 Std L" style="font-size: 12pt;"><br/></font></div><ul><li><div><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">Python</span><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">语言和</span><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">GIL</span><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">是没有什么联系的。仅仅是由于历史原因存在与</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">Cpython</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">虚拟机</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">(</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">解释器</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">)</span><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">，</span><span style="font-size: 12pt; font-family: &quot;Adobe 宋体 Std L&quot;;">在Cpython的设计之初，为了解决多线程的数据完整性和状态同步从而加了一把超级大锁，也就是GIL。而当越来越多的模块依赖了这一特性后，就变的难以移除了。</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="background-color: rgb(255, 250, 165); font-size: 12pt;-evernote-highlight:true;">对多线程的影响</span></div></li><li><div><span style="font-size: 12pt;">由于GIL的存在，其实每个CPU在同一时刻只会执行一个线程（在单核CPU下的多线程其实都只是并发，不是并行，并发和并行从宏观上来讲都是同时处理多路请求的概念。但并发和并行又有区别，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。）</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 12pt;">在Python多线程下，每个线程的执行方式：</span></div></li><ul><ol><li><div><span style="font-size: 12pt;">获取GIL</span></div></li><li><div><span style="font-size: 12pt;">执行代码直到sleep或者是python虚拟机将其挂起。</span></div></li><li><div><span style="font-size: 12pt;">释放GIL</span></div></li></ol><li><div><span style="font-size: 16px;">也就是说只有某一线程获取到GIL的时候才会执行，而由于当前进程只存在一个GIL，所以同一时刻只会有一个线程执行。</span><span style="font-size: 12pt;">而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。</span><span style="font-size: 16px;">因此即使在多核CPU上，多线程执行效率也不理想。</span></div></li><li><div><span style="font-size: 16px;">如果想利用多核资源，可以使用多进程。<span style="font-size: 12pt;">每个进程有各自独立的GIL，互不干扰，这样就可以真正意义上的并行执行，提高执行效率</span></span></div></li></ul></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 16px;">线程释放GIL的情况</span></div></li><ul><li><div><span style="font-size: 12pt; font-family: 宋体;">在</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">IO</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">操作等可能会引起阻塞的</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">system call</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">之前</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">,</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">可以暂时释放</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">GIL,</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">但在执行完毕后</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">,</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">必须重新获取</span><span style="font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">GIL</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">Python 3.x</span><span style="font-size: 12pt; font-family: 宋体;">使用计时器（执行时间达到阈值后，当前线程释放</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">GIL</span><span style="font-size: 12pt; font-family: 宋体;">）</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">Python 2.x</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: 宋体;">，</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">tickets</span><span style="font-size: 12pt; font-family: 宋体;">计数达到</span><span style="font-family: &quot;Source Code Pro&quot;; font-size: 12pt;">100（</span><span style="font-size: 12pt; font-family: &quot;Source Code Pro&quot;;">ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整）</span><span style="font-family: &quot;Source Code Pro&quot;; font-size: 12pt;">）</span></div></li></ul></ul><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 16px;">Python多线程的作用</span></div></li><ol><li><div><span style="font-size: 12pt;">CPU密集型代码(各种循环处理、计数等等)，在这种情况下，</span></div></li><ol><li><div><span style="font-size: 12pt;">Python2.X 中 ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以python2下的多线程对CPU密集型代码并不友好。</span></div></li><li><div><span style="font-size: 12pt;">而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL），这样对CPU密集型程序会比较友好，<span style="font-size: 12pt;">但依然没有解决GIL导致的同一时间只能执行一个线程的问题，所以效率依然不尽如人意。</span></span></div></li></ol><li><div><span style="font-size: 12pt;">IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以python的多线程对IO密集型代码比较友好。</span></div></li></ol></ul><div><font style="font-size: 12pt;"><br style="color: rgb(26, 26, 26); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/></font></div><div><font style="font-size: 12pt;"><br style="color: rgb(26, 26, 26); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/></font></div><ul><li><div><span style="font-size: 12pt;">多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低</span></div></li></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><ul><li><div><span style="font-size: 16px; letter-spacing: 0.2px; orphans: 3; text-indent: 0px; text-transform: none; white-space: normal; widows: 3; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(133, 133, 133); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">既然CPython解释存在GIL是否意味每个线程在全局变量就不用加Lock互斥锁了呢</span></div></li><ul><li><div><span style="font-size: 16px; letter-spacing: 0.2px; orphans: 3; text-indent: 0px; text-transform: none; white-space: normal; widows: 3; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(133, 133, 133); font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">这是一个严重错误的想法，为什么用户操作全局数据还需要加Lock，因为GIL的释放时机我们无法控制-操作非常可能并没有完成，而不像Lock那样我们用完才释放(操作完整)。</span></div></li></ul></ul><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br style="color: rgb(26, 26, 26); font-family: -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Source Han Sans SC&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"/></font></div><div><span style="font-size: 12pt;"><br/></span></div></div><div><br/></div></body></html>