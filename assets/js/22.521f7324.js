(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{371:function(v,_,l){"use strict";l.r(_);var i=l(42),t=Object(i.a)({},(function(){var v=this,_=v.$createElement,l=v._self._c||_;return l("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[l("h3",{attrs:{id:"引言"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#引言"}},[v._v("#")]),v._v(" 引言")]),v._v(" "),l("ul",[l("li",[v._v("短小精悍")]),v._v(" "),l("li",[v._v("语音特性")]),v._v(" "),l("li",[v._v("没有类和继承的概念,通过接口(interface) 来实现多态性")]),v._v(" "),l("li",[v._v("静态,强类型")]),v._v(" "),l("li",[v._v("支持交叉编译,完全支持 UTF-8")]),v._v(" "),l("li",[v._v("提供了海量的并行支持")]),v._v(" "),l("li",[v._v("不适合用来开发对实时性要求很高的软件\n"),l("ul",[l("li",[v._v("因为垃圾回收和自动内存分配")])])])]),v._v(" "),l("h3",{attrs:{id:"格式化代码"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#格式化代码"}},[v._v("#")]),v._v(" 格式化代码")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("gofmt")])]),v._v(" "),l("li",[l("p",[v._v("格式化该源文件,并覆盖原始内容")]),v._v(" "),l("ul",[l("li",[v._v("gofmt –w program.go")]),v._v(" "),l("li",[v._v("如果不加 -w 则只会打印格式化后的结果而不重写文件")])])]),v._v(" "),l("li",[l("p",[v._v("格式化并重写所有go源文件")]),v._v(" "),l("ul",[l("li",[v._v("gofmt -w *.go")])])]),v._v(" "),l("li",[l("p",[v._v("格式化并重写map1目录及其子目录下的所有Go源文件")]),v._v(" "),l("ul",[l("li",[v._v("gofmt map1")])])]),v._v(" "),l("li",[l("p",[v._v("简单的代码重构(替换)")]),v._v(" "),l("ul",[l("li",[v._v("```go # 去掉多余的括号 gofmt -r '(a) -> a' –w *.go")])]),v._v(" "),l("p",[v._v("# 将源文件中多余的 len(a)去掉 gofmt -r 'a[n:len(a)] -> a[n:]' –w *.go ```")])])]),v._v(" "),l("h3",{attrs:{id:"生成代码文档"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#生成代码文档"}},[v._v("#")]),v._v(" 生成代码文档")]),v._v(" "),l("ul",[l("li",[v._v("go doc "),l("a",{attrs:{href:"https://cucurbitbrothers.github.io/Essay/Language/Golang/go/%5Bhttp://golang.org/cmd/godoc/%5D(http://golang.org/cmd/godoc/)%EF%BC%88",target:"_blank",rel:"noopener noreferrer"}},[v._v("链接"),l("OutboundLink")],1)]),v._v(" "),l("li",[v._v("一般用法")]),v._v(" "),l("li",[l("code",[v._v("go doc package")]),v._v(" 获取包的文档注释，例如："),l("code",[v._v("go doc fmt")]),v._v(" 会显示使用 "),l("code",[v._v("godoc")]),v._v(" 生成的 "),l("code",[v._v("fmt")]),v._v(" 包的文档注释。")]),v._v(" "),l("li",[l("code",[v._v("go doc package/subpackage")]),v._v(" 获取子包的文档注释，例如："),l("code",[v._v("go doc container/list")]),v._v("。")]),v._v(" "),l("li",[l("code",[v._v("go doc package function")]),v._v(" 获取某个函数在某个包中的文档注释，例如："),l("code",[v._v("go doc fmt Printf")]),v._v(" 会显示有关 "),l("code",[v._v("fmt.Printf()")]),v._v(" 的使用说明。")])]),v._v(" "),l("h3",{attrs:{id:"其他工具"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#其他工具"}},[v._v("#")]),v._v(" 其他工具")]),v._v(" "),l("ul",[l("li",[v._v("go install")]),v._v(" "),l("li",[v._v("安装go包的工具")]),v._v(" "),l("li",[v._v("go fix")]),v._v(" "),l("li",[v._v("将你的Go代码从旧的发行版迁移到最新的发行版")]),v._v(" "),l("li",[v._v("go test")]),v._v(" "),l("li",[v._v("轻量级单元测试框架")])]),v._v(" "),l("h3",{attrs:{id:"基本结构和要素"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基本结构和要素"}},[v._v("#")]),v._v(" 基本结构和要素")]),v._v(" "),l("ul",[l("li",[l("p",[v._v("可见性规则")])]),v._v(" "),l("li",[l("p",[v._v("标识符 以大写字母(任何Unicode编码)开头 ——> public")])]),v._v(" "),l("li",[l("p",[v._v("标识符 以小写字母开头 ——> private")])]),v._v(" "),l("li",[l("p",[v._v("包的别名")])]),v._v(" "),l("li",[l("p",[v._v("```go package main")]),v._v(" "),l("p",[v._v('import fm "fmt" // alias3')]),v._v(" "),l("p",[v._v('func main() { fm.Println("hello, world") } ```')])]),v._v(" "),l("li",[l("p",[v._v("函数")])]),v._v(" "),l("li",[l("p",[l("code",[v._v("go func functionName(parameter_list) (return_value_list) { … }")])]),v._v(" "),l("ul",[l("li",[v._v("parameter_list 的形式为 (param1 type1, param2 type2, …)")]),v._v(" "),l("li",[v._v("return_value_list 的形式为 (ret1 type1, ret2 type2, …)")])])]),v._v(" "),l("li",[l("p",[v._v("main 函数是一个可执行程序必须包含的, 一般来说是启动后第一个执行的函数(如果有init() 函数则会先执行该函数). 它没有参数,也没有返回类型")])]),v._v(" "),l("li",[l("p",[v._v("类型")])]),v._v(" "),l("li",[l("p",[v._v("基本类型:")]),v._v(" "),l("ul",[l("li",[v._v("int、float、bool、string")])])]),v._v(" "),l("li",[l("p",[v._v("结构化:")]),v._v(" "),l("ul",[l("li",[v._v("struct、array、slice、map、channel")])])]),v._v(" "),l("li",[l("p",[v._v("只描述行为")]),v._v(" "),l("ul",[l("li",[v._v("interface")])])]),v._v(" "),l("li",[l("p",[v._v("类型转换")])]),v._v(" "),l("li",[l("p",[v._v("不支持隐式转换, 必须显式说明")])]),v._v(" "),l("li",[l("p",[v._v("常量")])]),v._v(" "),l("li",[l("p",[v._v("const")])]),v._v(" "),l("li",[l("p",[v._v("只能是基本类型")])]),v._v(" "),l("li",[l("p",[v._v("iota")])]),v._v(" "),l("li",[l("p",[v._v("变量")])]),v._v(" "),l("li",[l("p",[v._v("var")])]),v._v(" "),l("li",[l("p",[v._v("```go // var identifier type var a int var ( b bool str string )")]),v._v(" "),l("p",[v._v("// var identifier [type] = value var a int = 15")]),v._v(" "),l("p",[v._v("a := 1 ```")])]),v._v(" "),l("li",[l("p",[v._v("声明后会自动赋予它该类型的零值")])]),v._v(" "),l("li",[l("p",[v._v("命名规则遵循驼峰命名法(public 需要首字母大写)")])]),v._v(" "),l("li",[l("p",[v._v("如果局部变量和全局变量同名, 全局变量会暂时隐藏")])]),v._v(" "),l("li",[l("p",[v._v("值类型和引用类型")])]),v._v(" "),l("li",[l("p",[v._v("值类型")]),v._v(" "),l("ul",[l("li",[v._v("int、float、bool 和 string 这些基本类型都属于值类型; 数组, 结构这些复合类型也是值类型")]),v._v(" "),l("li",[v._v("= 是将内存中的值进行了拷贝")]),v._v(" "),l("li",[v._v("值类型的变量的值存储在栈中")])])]),v._v(" "),l("li",[l("p",[v._v("引用类型")]),v._v(" "),l("ul",[l("li",[v._v("指针(内存地址), slices, maps, channel")]),v._v(" "),l("li",[v._v("同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址")]),v._v(" "),l("li",[v._v("被引用的变量存储在堆中, 以便进行垃圾回收,且比栈拥有更大的内存空间")])])]),v._v(" "),l("li",[l("p",[v._v("打印")])]),v._v(" "),l("li",[l("p",[v._v("Printf, Println")])]),v._v(" "),l("li",[l("p",[v._v("Sprintf, 与Printf作用相同,只是会将格式化后的字符串返回")])]),v._v(" "),l("li",[l("p",[v._v("init 函数")])]),v._v(" "),l("li",[l("p",[v._v("变量除了在全局声明中初始化,也可以在init函数中初始化")])]),v._v(" "),l("li",[l("p",[v._v("每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行")])]),v._v(" "),l("li",[l("p",[v._v("开始执行程序前对数据进行检验或修复, 以保障程序状态的正确性")])])]),v._v(" "),l("h3",{attrs:{id:"基本类型和运算符"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#基本类型和运算符"}},[v._v("#")]),v._v(" 基本类型和运算符")]),v._v(" "),l("ul",[l("li",[v._v("基本类型")]),v._v(" "),l("li",[v._v("bool")]),v._v(" "),l("li",[v._v("数字类型\n"),l("ul",[l("li",[v._v("int,")]),v._v(" "),l("li",[v._v("float32(小数点后7位), float64(小数点后15位),")]),v._v(" "),l("li",[v._v("complex64 (32 位实数和虚数), complex128 (64 位实数和虚数)")]),v._v(" "),l("li",[v._v("也支持基于架构的类型")]),v._v(" "),l("li",[v._v("尽可能使用float64, math包中关于数学运算的函数都会要去接受这个类型")]),v._v(" "),l("li",[v._v("进制")]),v._v(" "),l("li",[v._v("增加前缀0 表示8进制")]),v._v(" "),l("li",[v._v("增加前缀0x表示16进制")]),v._v(" "),l("li",[v._v("使用e 表示10的连乘")]),v._v(" "),l("li",[v._v("复数")]),v._v(" "),l("li",[v._v("re+imI")]),v._v(" "),l("li",[v._v("函数 "),l("code",[v._v("real(c)")]),v._v(" 和 "),l("code",[v._v("imag(c)")]),v._v(" 可以分别获得相应的实数和虚数部分")]),v._v(" "),l("li",[v._v("推荐使用complex128")])])]),v._v(" "),l("li",[v._v("运算符")]),v._v(" "),l("li",[v._v("逻辑运算\n"),l("ul",[l("li",[v._v("&& 和 || 是具有快捷性质的运算符")])])]),v._v(" "),l("li",[v._v("位运算\n"),l("ul",[l("li",[v._v("只能用于整数类型的变量,且需要等长位模式")])])]),v._v(" "),l("li",[v._v("算术运算符\n"),l("ul",[l("li",[l("code",[v._v("/")]),v._v(" 对于整数运算而言，结果依旧为整数")]),v._v(" "),l("li",[v._v("取余运算符只能作用于整数")]),v._v(" "),l("li",[v._v("++ — 只能作为语句, 而非表达式")]),v._v(" "),l("li",[v._v("溢出将会 抛弃超出位数")])])]),v._v(" "),l("li",[v._v("随机数\n"),l("ul",[l("li",[v._v("rand")])])]),v._v(" "),l("li",[v._v("优先级")]),v._v(" "),l("li",[v._v("类型别名")]),v._v(" "),l("li",[v._v("使用某个类型是,可以起一个别名")])])])}),[],!1,null,null,null);_.default=t.exports}}]);