# 基础 08-面向对象

**问题**

1. 实现with语句，要实现那个魔方方法
    * 实现\_\_enter\_\_和\_\_exit\_\_方法后，就能通过with语句进行上下文管理

**面向对象基础**

* 类

                00经典类（旧式类）：class Hero:                    class Hero\(\):

                新式类：class Hero\( object \):

                    区别：

                        新式类都从object继承，经典类不需要。

                        MRO\(method resolution order 基类搜索顺序 / 多继承调用顺序\)：

                            新式类：C3算法（广度优先搜索）

                            旧式类：深度优先搜索

                        新式类相同父类只执行一次构造函数，经典类重复执行多次。

                

                

                Python2中，经典类没有父类，新式类继承 object类

                Python3中，经典类和新式类都继承 object 类

                

            2. 面向对象

            （1）在python中方法名如果是\_\_xxxx\_\_\(\)的，那么就有特殊的功能，因此叫做“魔法”方法 \_\_str\_\_（ 必须有返回值）

                返回一个字符串，作为这个对象的描述信息,追踪对象属性的变化

                在使用print 输出时，默认打印对象的内存地址，如果类里面定义了\_\_str\_\_\(self\)方法，就会打印从这个方法中return的数据

            （2）\_\_del\_\_\(\)方法

                经常会在  \_\_del\_\_\(\) 方法中做一些处理

                当有变量保存了一个对象的引用时，该对象的引用计数就会加  1

                使用 del 删除变量指向的对象时，就会减少对象的引用计数（每次减 1 ），当引用计数为0 时，对象才会真的被删除（内存被回收）

            3. 继承，封装

                i. 继承，子类会继承父类的\_\_init\_\_方法，所以子类会继承父类的属性

            1、调用父类方法

                    super\(FooChild,self\).\_\_init\_\_\(\)

         super\(FooChild, self\).bar\(message\)

                    super\(child\_class, child\_object\).parent\_attribute\(arg\)

                  使用super\(\) 可以逐一调用所有的父类方法，并且只执行一次。调用顺序遵循 mro 类属性的顺序。

                    super\(\) 带参数版本，只支持新式类

                    super\(cls, self\).make\_cake\(\)

                    

                    super\(\)的简化版，只支持新式类

                    super\(\).make\_cake\(\)

                    如果继承了多个父类，且父类都有同名方法，则默认只执行第一个父类的\(同名方法只执行一次，目前super\(\)不支持执行多个父类的同名方法\)

                

                所以在以后的开发中，如果重写了父类的\_\_init\_\_方法，最好是先调用父类的这个方法，然后再添加自己的功能，（完成父类的初始化工作，以保证程序的稳定）

                

            3、封装的意义：

                （1）、将属性和方法放到一起作为一个整体，然后通过实例化对象来处理

                （2）、隐藏内部细节，只需要和对象的方法和属性进行交互

                （3）、可以对属性和方法增加权限

            2、私有权限：在属性名或方法名前面加两个下划线\_\_

                不能通过对象处理，起到安全作用

                

                如果子类继承了父类，子类就是继承父类的共有属性和共有方法，子类不能直接使用父类的私有属性和私有方法

                

                子类可以调用父类的私有属性和私有方法，但是不合法。                               

                        dir\(\) 函数不带参数时，返回当前范围内的变量、方法和定义的类型   列表；

                        带参数时，返回参数的属性、方法列表。

                        如果参数包含方法\_\_dir\_\_\(\)，该方法将被调用。

                        如果参数不包含\_\_dir\_\_\(\)，该方法将最大限度地收集参数信息。

                        

            4. 多态 （定义时的类型和运行时的类型不一样，此时就称为多态）

                i. Python的多态，就是弱化类型（鸭子类型），重点在于对象参数是否有指定的属性和方法，如果有就认定合适，而不关心对象的类型是否正确。

                    传入不同的对象，（类型不同）

                    都有相同的属性和方法，可以正常访问，称为多态

                    多态的作用：增强一个函数或者方法的复用性

                ii. 类属性和实例属性

                类属性：就是类对象所拥有的属性，被所有类对象的实例对象所共有，在内存中值存在一个副本，类似于C\+\+中的静态对象

                实例属性：对象属性，无法通过     类名.属性名     进行访问

                    如果一个类有多个对象，每个对象的属性是各自保存的，都有各自独立的地址

                    

                如果需要在类外修改类属性，必须通过类对象去引用然后进行修改。如果通过实例对象去引用，会产生一个同名的实例属性，这种方式修改的是实例属性，不会影响到类属性，并且之后如果通过实例对象去引用该名称的属性，实例属性会强制屏蔽掉类属性，即引用的是实例属性，除非删除了该实例属性

                iii. 类方法和静态方法

                类方法：修饰器@classmethod来标识其为类方法，（一般以cls作为第一个参数）

                静态方法：通过修饰器@staticmethod来进行修饰，静态方法不需要多定义参数，可以通过对象和类来访问

                iv. 类方法、实例方法、静态方法的区别

                类方法使用classmethod标识，静态方法使用@staticmethod 来修饰。实例方法就是剩下的方法

                都可以通过类名或对象名进行调用，不过实例方法通过类名进行调用时需要传入一个对象参数。

            5. \_\_new\_\_方法

                \_\_new\_\_至少要有一个参数cls，代表要实例化的类

                \_\_new\_\_必须要有返回值，返回实例化出来的实例。可以return父类\_\_new\_\_出来的实例，或者直接是object的\_\_new\_\_出来的实例

                    return  object.\_\_new\_\_\(cls\)

            6. 单例模式

            确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，单例模式是一种对象创建型模式。

                保证只有1个对象

                只执行一次\_\_init\_\_方法

                    class Singleton\(object\):

                        \_\_instance = None

                        \_\_is\_first = True

                        def \_\_new\_\_\(cls, age, name\):  \# 实例化

                            if not cls.\_\_instance:

                                cls.\_\_instance = object.\_\_new\_\_\(cls\)

                            return cls.\_\_instance

                        def \_\_init\_\_\(self, age, name\):  \# 初始化

                            if self. \_\_is\_first:

                                self.age = age

                                self.name = name

                                Singleton. \_\_is\_first = False

                

            7. 概念知识：

                i. 面向对象（object oriented programing  OOP）：

                    博大，将一类事物的共同属性进行抽象，将其所有的属性、行为按功能进行集合；

                    把事物分解成不同的对象，建立对象的目的不是完成某一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为

                    可以加快开发速度，减少代码重复

                面向过程（ procedure oriented programing  POP）：

                    精深，思考到事物发展的每一步，细发如丝，考虑到任何一种可能发生的情况，一步步执行，判断，直至事物的结束。

                    根据业务逻辑用函数把这些步骤一步步实现，然后在一一调用（自顶向下，逐步细化）

                    随着系统的膨胀，面向过程将无法应付，最终崩溃

                优缺点：

                    面型对象： 易维护、复用、扩展，系统使用灵活方便；

                            性能低于面向过程

                    面向过程：性能更优，消耗资源少

                            难以维护、复用、扩展。

                ii.

                    1\) 类：具有相似内部状态和运动规律的实体集合（或抽象）

                    2\) 对象：某一个类的具体存在

                

 
