<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.4.0 (460661)"/><meta name="altitude" content="68.45928955078125"/><meta name="author" content="1404001663@qq.com"/><meta name="created" content="2018-09-28 06:38:15 +0000"/><meta name="latitude" content="39.98086159092524"/><meta name="longitude" content="116.3071481869356"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-12-12 13:15:34 +0000"/><title>006-Database</title></head><body><ol><li><div>Django中：</div></li><ol><li><div><span style="background-color: rgb(255, 250, 165); font-size: 14px; font-family: Menlo;-evernote-highlight:true;">models.ForeignKey（</span><span style="font-size: 14px; font-family: Menlo;">）</span></div></li><ul><li><div><span style="font-family: Menlo;">related_name</span></div></li><ul><li><div><span style="font-family: Menlo;">定义之后就无法使用“_set”查询，会被“related_name”代替</span></div></li><li><div><span style="font-family: Menlo;">如果</span><span style="font-size: 11.3pt;"><span style="font-size: 11.3pt; color: rgb(62, 75, 200); font-family: Menlo;">related_name</span></span><span style="background-color: rgb(255, 255, 255); font-size: 11.3pt; font-family: Menlo;">=</span><span style="font-size: 11.3pt; font-family: Menlo; font-weight: bold;">"+"</span><span style="font-family: Menlo;">或者以“+”结束：就无法进行逆向查询了</span></div></li></ul><li><div><span style="font-family: Menlo;"><span style="font-family: Menlo; color: rgb(61, 66, 200);">db_constraint</span>=True</span></div></li><ul><li><div><span style="font-family: Menlo;">是否在数据库中创建外键约束</span></div></li></ul></ul><li><div><span style="background-color: rgb(255, 250, 165); font-family: Menlo;-evernote-highlight:true;">@transaction.atomic（</span><span style="font-family: Menlo;">）</span></div></li><ul><li><div><span style="font-family: Menlo;">开启数据库事物</span></div></li></ul><li><div><span style="font-family: Menlo;">查询条件</span></div></li><ol><li><div><span style="font-family: Menlo;">iexact： 忽略大小写的 like</span></div></li><li><div><span style="font-family: Menlo;">exact：  like</span></div></li></ol><li><div><span style="font-size: 14px;">优化</span></div></li><ol><li><div><span style="background-color: rgb(255, 250, 165); font-size: 14px;-evernote-highlight:true;"><span style="font-size: 11.3pt; caret-color: rgb(51, 51, 51); background-color: rgb(255, 250, 165); color: rgb(0, 0, 0); font-family: Menlo;-evernote-highlight:true;">select_related()</span></span></div></li><ol><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">主要针一对一和多对一关系进行优化</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能</span></div></li><li><div><span style="box-sizing: border-box; outline: 0px; word-break: break-all; color: rgb(51, 51, 51);">可以通过可变长参数指定需要select_related的字段名。也可以通过使用双下划线“__”连接字段名来实现指定的递归查询，没有指定的字段不会缓存，没有指定的深度不会缓存，如果要访问的话Django会再次进行SQL查询。</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">也可以通过depth参数指定递归的深度，Django会自动缓存指定深度内所有的字段。如果要访问指定深度外的字段，Django会再次进行SQL查询</span></div></li><li><div><span style="box-sizing: border-box; outline: 0px; word-break: break-all; color: rgb(51, 51, 51);">也接受无参数的调用，Django会尽可能深的递归查询所有的字段。但注意有Django递归的限制和性能的浪费。</span></div></li><li><div><span style="box-sizing: border-box; outline: 0px; word-break: break-all; color: rgb(51, 51, 51);">Django &gt;= 1.7，链式调用的select_related相当于使用可变长参数。Django &lt; 1.7，链式调用会导致前边的select_related失效，只保留最后一个。</span></div></li></ol><li><div><font style="font-size: 14px;"><span style="caret-color: rgb(51, 51, 51); background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="font-size: 11.3pt; background-color: rgb(255, 250, 165); color: rgb(0, 0, 0); font-family: Menlo;-evernote-highlight:true;">prefetch_related()</span></span></font></div></li><ol><li><div><span style="font-family: Menlo;">prefetch_related主要针一对多和多对多关系进行优化。</span></div></li><li><div><span style="font-family: Menlo;">prefetch_related通过分别获取各个表的内容，然后用Python处理他们之间的关系来进行优化。</span></div></li><li><div><span style="font-family: Menlo;">可以通过可变长参数指定需要</span><span style="font-family: Menlo;">prefetch_related</span><span style="font-family: Menlo;">的字段名。指定方式和特征与select_related是相同的。</span></div></li><li><div><span style="font-family: Menlo;">在Django &gt;= 1.7可以通过Prefetch对象来实现复杂查询，但低版本的Django好像只能自己实现。</span></div></li><li><div><span style="font-family: Menlo;">作为prefetch_related的参数，Prefetch对象和字符串可以混用。</span></div></li><li><div><span style="font-family: Menlo;">prefetch_related的链式调用会将对应的prefetch添加进去，而非替换，似乎没有基于不同版本上区别。</span></div></li><li><div><span style="font-family: Menlo;">可以通过传入None来清空之前的prefetch_related。</span></div></li></ol><li><div><span style="background-color: rgb(255, 250, 165); font-size: 11.3pt; caret-color: rgb(51, 51, 51); color: rgb(0, 0, 0); font-family: Menlo;-evernote-highlight:true;">select_related</span><span style="font-family: Menlo;"> 和 </span><span style="font-size: 11.3pt; caret-color: rgb(51, 51, 51); background-color: rgb(255, 250, 165); color: rgb(0, 0, 0); font-family: Menlo;-evernote-highlight:true;">prefetch_related</span><span style="font-family: Menlo;">的应用</span></div></li><ol><li><div><span style="font-family: Menlo;">因为select_related()总是在单次SQL查询中解决问题，而prefetch_related()会对每个相关表进行SQL查询，因此select_related()的效率通常比后者高。</span></div></li><li><div><span style="font-family: Menlo;">鉴于第一条，尽可能的用select_related()解决问题。只有在select_related()不能解决问题的时候再去想prefetch_related()。</span></div></li><li><div><span style="font-family: Menlo;">你可以在一个QuerySet中同时使用select_related()和prefetch_related()，从而减少SQL查询的次数。</span></div></li><li><div><span style="font-family: Menlo;">只有prefetch_related()之前的select_related()是有效的，之后的将会被无视掉。</span></div></li><li><div><span style="caret-color: rgb(51, 51, 51); font-size: 14.399999618530273px; letter-spacing: normal; text-indent: 0px; text-transform: none; white-space: pre-wrap; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Lucida Console&quot;, Consolas, Courier, monospace; font-variant-caps: normal;">select_related是通过join来关联多表，一次获取数据，存放在内存中，但如果关联的表太多，会严重影响数据库性能。prefetch_related是通过分表，先获取各个表的数据，存放在内存中，然后通过Python处理他们之间的关联。</span></div></li></ol><li><div><span style="font-size: 11.3pt; color: rgb(0, 0, 0); font-family: Menlo;">bulk_create</span></div></li><ol><li><div><span style="color: rgb(51, 51, 51); font-family: Menlo;">Django（1.4之后）  model中批量导入数据</span></div></li><li><div><span style="color: rgb(51, 51, 51); font-family: Menlo;">只连接一次数据库</span></div></li></ol></ol><li><div>BinaryField</div></li><ol><li><div><span style="font-family: 宋体;">在</span>django 1.6<span style="font-family: 宋体;">中</span>, <span style="font-family: 宋体;">新增了</span>BinaryField, <span style="font-family: 宋体;">用于储存二进制数据</span>(binary data<span style="font-family: 宋体;">或</span> bytes). <span style="font-family: 宋体;">对于</span>BinaryField, <span style="font-family: 宋体;">我们无法使用</span>ORM<span style="font-family: 宋体;">的</span>filters, excludes<span style="font-family: 宋体;">或其他</span>SQL<span style="font-family: 宋体;">操作</span>. <span style="font-family: 宋体;">但在少数情况下</span>, <span style="font-family: 宋体;">我们会用到</span>BinaryField, <span style="font-family: 宋体;">例如</span>MessagePack<span style="font-family: 宋体;">格式的内容</span>, <span style="font-family: 宋体;">传感器接受的原始数据和压缩数据等</span>. <span style="font-family: 宋体;">但需要注意</span> <span style="font-family: 宋体;">的是</span>, Binary Data<span style="font-family: 宋体;">一般都十分庞大</span>, <span style="font-family: 宋体;">因此可能会拖慢数据库的速度</span>. <span style="font-family: 宋体;">如果发生这一现象</span>, <span style="font-family: 宋体;">我们可以将</span>binary data<span style="font-family: 宋体;">储存在文件中</span>, <span style="font-family: 宋体;">然后使用</span>FileField<span style="font-family: 宋体;">储</span> <span style="font-family: 宋体;">存该文件的路径信息。</span></div></li><li><div> <span style="font-family: 宋体;">还有</span>, <span style="font-family: 宋体;">不要从</span>BinaryField<span style="font-family: 宋体;">中直接读取文件并呈献给用户</span>. <span style="font-family: 宋体;">因为</span>, 1. <span style="font-family: 宋体;">从数据库读写总是比从文件系统读写慢</span>; 2. <span style="font-family: 宋体;">数据库备份会变得十分庞大</span>, <span style="font-family: 宋体;">花费更多</span> <span style="font-family: 宋体;">的时间</span>; 3. <span style="font-family: 宋体;">获得文件的过程</span>, <span style="font-family: 宋体;">增加了从</span>django<span style="font-family: 宋体;">到数据库的这一环节</span>.</div></li><ol><li><div><span style="font-family: 宋体;">用于存放原始二进制数据，或</span> bytes<span style="font-family: 宋体;">。在该类型项上无法进行</span> filter<span style="font-family: 宋体;">、</span>exclude <span style="font-family: 宋体;">或其它的</span> SQL <span style="font-family: 宋体;">操作。但它在以下情况下有用:</span></div></li><li><div>MessagePack <span style="font-family: 宋体;">格式的内容</span>
</div></li><li><div><span style="font-family: 宋体;">传感器原始数据</span></div></li><li><div><span style="font-family: 宋体;">压缩的数据。如</span> Sentry <span style="font-family: 宋体;">保存为</span> BLOB <span style="font-family: 宋体;">的数据，</span> <span style="font-family: 宋体;">但是由于历史原因需要进行</span> base64 <span style="font-family: 宋体;">编码</span>
</div></li><li><div><span style="font-family: 宋体;">二进制数据串可以会很大，这将会拖慢数据库。此时应将内容保存在一个文件中，然后用</span> FileField <span style="font-family: 宋体;">来引用</span></div></li><li><div><span style="font-family: 宋体;">绝对不要通过</span> BinaryField <span style="font-family: 宋体;">提供文件服务</span> </div></li><ol><li><div><span style="font-family: 宋体;">对数据库的读写比对文件系统更慢</span></div></li><li><div><span style="font-family: 宋体;">你的数据库会变得越来越大，从而性能越来越低</span></div></li><li><div><span style="font-family: 宋体;">此时访问文件需要经过</span> Django <span style="font-family: 宋体;">应用层和数据库层共两层。</span></div></li></ol></ol><li><div><span style="font-family: 宋体;">BinaryField</span><span style="font-family: 宋体;">：二进制数据字段，只能通过</span><span style="font-family: 宋体;">bytes</span><span style="font-family: 宋体;">对其进行赋值。</span></div></li><li><div><span style="font-family: 宋体;"
/><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">默认情况下，</span><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">BinaryField</span><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">设置</span><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">editable</span><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">为</span><span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">False，<span style="font-size: 14px; color: rgb(25, 31, 37); font-family: 宋体; font-stretch: normal; font-style: normal; font-variant-caps: normal; font-weight: normal; line-height: normal;">该字段将不会显示在管理员或任何其他字段中 ModelForm。在模型验证期间也会跳过它们</span></span></div></li><li><div><span style="caret-color: rgb(25, 31, 37); color: rgb(25, 31, 37); font-family: 宋体;">压缩时不会产生编码问题，</span></div></li></ol><li><div>为什么用数字，而不直接写字符串</div></li><ol><li><div>直接存 int 虽然可读性不高，但是效率高，有助于比较</div></li><li><div>修改状态的话可以不改动数据，只改动逻辑</div></li><li><div>字符串会降低查询和连接的性能，并会增加存储开销，因为引擎在处理查询和连接时会逐个比较字符串中的每一个字符，而数字型一个就够了</div></li></ol></ol><li><div>原生</div></li><ol><li><div><br/></div></li><li><div><br/></div></li></ol><li><div>数据库设计</div></li><ol><li><div>流程</div></li><ol><li><div>需求分析阶段：综合各个用户的应用需求-----数据流程图（DFD）</div></li><li><div>概念设计阶段：形成独立于机器特点，独立于各个DBMS产品的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">概念模式</span>（E-R图）</div></li><li><div>逻辑设计阶段：先将E-R图转换成具体的数据库产品支持的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">数据模型</span>，如<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">关系模型</span>，形成数据库逻辑模式；然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图（View），相册数据的<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">外模式</span></div></li><li><div>物理设计阶段：根据DBMS特点和处理的需要，进行物理存储安排，建立<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">索引</span>，形成数据库<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">内模式</span>   </div></li></ol><li><div>关系</div></li><ol><li><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(47, 47, 47); font-family: &quot;Helvetica Neue&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">一对一（one-to-one）、一对多（one-to-many）以及多对多（many-to-many）。更进一步的，many-to-many实际上就是两个one-to-many。</span></span></div></li></ol></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><ul><li><div>SQL</div></li><ul><li><div><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 128); font-family: Menlo; font-size: 11.3pt; font-weight: bold;">UPDATE </span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">plugin_rule_group </span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 128); font-family: Menlo; font-size: 11.3pt; font-weight: bold;">SET </span><span style="background-color: rgb(255, 255, 255); color: rgb(102, 14, 122); font-family: Menlo; font-size: 11.3pt; font-weight: bold;">name</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">=</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt; font-style: italic;">CONCAT</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">(</span><span style="background-color: rgb(255, 255, 255); color: rgb(102, 14, 122); font-family: Menlo; font-size: 11.3pt; font-weight: bold;">name</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">,</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 128, 0); font-family: Menlo; font-size: 11.3pt; font-weight: bold;">'插件'</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">)</span><span style="background-color: rgb(255, 255, 255); color: rgb(0, 0, 0); font-family: Menlo; font-size: 11.3pt;">;</span></div></li></ul></ul><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></body></html>