<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>开发规范 | 娃哈哈</title>
    <meta name="generator" content="VuePress 1.5.2">
    
    <meta name="description" content="">
    <link rel="preload" href="/Essay/assets/css/0.styles.cc042617.css" as="style"><link rel="preload" href="/Essay/assets/js/app.dc899fd4.js" as="script"><link rel="preload" href="/Essay/assets/js/2.b39f6721.js" as="script"><link rel="preload" href="/Essay/assets/js/19.0fba421d.js" as="script"><link rel="prefetch" href="/Essay/assets/js/10.2ab5698a.js"><link rel="prefetch" href="/Essay/assets/js/11.2ee32479.js"><link rel="prefetch" href="/Essay/assets/js/12.660ecc97.js"><link rel="prefetch" href="/Essay/assets/js/13.9c28e188.js"><link rel="prefetch" href="/Essay/assets/js/14.3f276af8.js"><link rel="prefetch" href="/Essay/assets/js/15.b6143312.js"><link rel="prefetch" href="/Essay/assets/js/16.cd95fbf3.js"><link rel="prefetch" href="/Essay/assets/js/17.99c0281f.js"><link rel="prefetch" href="/Essay/assets/js/18.872d0b3e.js"><link rel="prefetch" href="/Essay/assets/js/20.1814ceb2.js"><link rel="prefetch" href="/Essay/assets/js/21.f9342e65.js"><link rel="prefetch" href="/Essay/assets/js/22.7987cb24.js"><link rel="prefetch" href="/Essay/assets/js/23.8ac78996.js"><link rel="prefetch" href="/Essay/assets/js/24.17c8cb49.js"><link rel="prefetch" href="/Essay/assets/js/25.ab787db3.js"><link rel="prefetch" href="/Essay/assets/js/26.ab3b1a7c.js"><link rel="prefetch" href="/Essay/assets/js/27.0711a038.js"><link rel="prefetch" href="/Essay/assets/js/28.6164fc0b.js"><link rel="prefetch" href="/Essay/assets/js/29.d24c9e33.js"><link rel="prefetch" href="/Essay/assets/js/3.b778373a.js"><link rel="prefetch" href="/Essay/assets/js/30.02572177.js"><link rel="prefetch" href="/Essay/assets/js/31.2de825fe.js"><link rel="prefetch" href="/Essay/assets/js/32.984618e0.js"><link rel="prefetch" href="/Essay/assets/js/33.f8118ff0.js"><link rel="prefetch" href="/Essay/assets/js/34.960a3ec4.js"><link rel="prefetch" href="/Essay/assets/js/35.bd36e5db.js"><link rel="prefetch" href="/Essay/assets/js/36.34e7febd.js"><link rel="prefetch" href="/Essay/assets/js/37.aa3e47d6.js"><link rel="prefetch" href="/Essay/assets/js/38.09ce9fc8.js"><link rel="prefetch" href="/Essay/assets/js/39.5fc7e1bc.js"><link rel="prefetch" href="/Essay/assets/js/4.d43be645.js"><link rel="prefetch" href="/Essay/assets/js/40.0029227e.js"><link rel="prefetch" href="/Essay/assets/js/41.e5c94479.js"><link rel="prefetch" href="/Essay/assets/js/42.8e0736d2.js"><link rel="prefetch" href="/Essay/assets/js/43.05017faf.js"><link rel="prefetch" href="/Essay/assets/js/5.7f0ca69d.js"><link rel="prefetch" href="/Essay/assets/js/6.71f74231.js"><link rel="prefetch" href="/Essay/assets/js/7.b3a916ad.js"><link rel="prefetch" href="/Essay/assets/js/8.9e4b4e92.js"><link rel="prefetch" href="/Essay/assets/js/9.bb656269.js">
    <link rel="stylesheet" href="/Essay/assets/css/0.styles.cc042617.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Essay/" class="home-link router-link-active"><!----> <span class="site-name">娃哈哈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/Essay/book/csapp.html" class="nav-link">
  book
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="github" class="dropdown-title"><span class="title">github</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/boyhaha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  娃哈哈
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/Essay/book/csapp.html" class="nav-link">
  book
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="github" class="dropdown-title"><span class="title">github</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/boyhaha" target="_blank" rel="noopener noreferrer" class="nav-link external">
  娃哈哈
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="开发规范"><a href="#开发规范" class="header-anchor">#</a> 开发规范</h3> <ul><li><a href="https://yq.aliyun.com/articles/531067" target="_blank" rel="noopener noreferrer">阿里云开发规范<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>按类划分, 不要多个业务共用</li> <li>越简单越容易管理</li></ul> <h3 id="进阶命令"><a href="#进阶命令" class="header-anchor">#</a> 进阶命令</h3> <h4 id="scan"><a href="#scan" class="header-anchor">#</a> scan</h4> <ul><li>代替 keys</li></ul> <div class="language- extra-class"><pre class="language-text"><code>SCAN cursor [MATCH pattern] [COUNT count]
</code></pre></div><h4 id="slow-log-慢查询日志"><a href="#slow-log-慢查询日志" class="header-anchor">#</a> SLOW LOG 慢查询日志</h4> <ul><li>Redis 服务器将所有的慢查询日志保存在服务器状态的 <code>slowlog</code> 链表中， 每个链表节点都包含一个 <code>slowlogEntry</code> 结构， 每个 <code>slowlogEntry</code> 结构代表一条慢查询日志</li></ul> <div class="language- extra-class"><pre class="language-text"><code>typedef struct slowlogEntry {
    // 唯一标识符
    long long id;

        // 命令执行时的时间，格式为 UNIX 时间戳
    time_t time;

    // 执行命令消耗的时间，以微秒为单位
    long long duration;

    // 命令与命令参数
    robj **argv;

    // 命令与命令参数的数量
    int argc;

} slowlogEntry;
</code></pre></div><ul><li>配置方法</li> <li>修改配置文件 <code>redis.conf</code> ，重启redis</li> <li>动态设置</li></ul> <div class="language- extra-class"><pre class="language-text"><code># 慢查询的阈值（单位：微秒）
# 不要设置过大，默认为 10 ms，通常可设置为 1ms。
# =0: 记录所有;  &lt;0: 不记录任何命令
slowlog-log-slower-than

# 指定服务器最多保存多少条慢查询日志, 默认值为 128
# 先进先出的队列; 固定长度; 保存在内存内, 可以定期持久化内存
# 不要设置过小，通常可设置在1000左右
slowlog-max-len

CONFIG SET slowlog-log-slower-than 0
</code></pre></div><ul><li>查询慢日志</li> <li>SLOWLOG GET [n]</li> <li>SLOWLOG LEN</li> <li>SLOWLOG RESET</li></ul> <h4 id="rename-command"><a href="#rename-command" class="header-anchor">#</a> rename-command</h4> <ul><li>在conf 配置文件中将一些高危命令重命名</li></ul> <div class="language- extra-class"><pre class="language-text"><code>rename-command flushall flushallall
rename-command keys keysys
</code></pre></div><h4 id="bigkeys"><a href="#bigkeys" class="header-anchor">#</a> bigkeys</h4> <ul><li>检查大 key.</li> <li>redis-cli -p 6380 --bigkeys</li> <li>string类型可以筛选出最占内存的key, 其他类型只能筛选出元素最多的key</li></ul> <h4 id="monitor"><a href="#monitor" class="header-anchor">#</a> monitor</h4> <ul><li>查看执行来源</li></ul> <h4 id="info"><a href="#info" class="header-anchor">#</a> info</h4> <ul><li>全面反映redis运行情况</li></ul> <h4 id="config"><a href="#config" class="header-anchor">#</a> config</h4> <ul><li>热修改 配置文件</li></ul> <div class="language- extra-class"><pre class="language-text"><code>config get *
config set xxx

# 将热修改的参数刷到redis配置文件, 避免重启时被原先的配置覆盖
config rewrite
</code></pre></div><h4 id="set"><a href="#set" class="header-anchor">#</a> set</h4> <ul><li>SET key value [EX seconds] [PX milliseconds] [NX|XX]</li></ul> <h3 id="redis-分布式锁"><a href="#redis-分布式锁" class="header-anchor">#</a> Redis 分布式锁</h3> <ul><li>redlock</li> <li>http://redis.cn/topics/distlock.html</li></ul> <h3 id="redis-数据过期策略"><a href="#redis-数据过期策略" class="header-anchor">#</a> Redis 数据过期策略</h3> <ul><li>设置过期时间</li> <li>expire key time(以秒为单位)--这是最常用的方式</li> <li>setex(String key, int seconds, String value)–字符串独有的方式</li> <li>过期策略</li> <li>过期方式
<ul><li>被动删除：</li> <li>当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li> <li>对CPU友好,但是对内存不友好, 甚至会造成内存泄漏</li> <li>主动删除(定期删除)：</li> <li>由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key</li> <li>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）</li> <li>常规的自检主要包括:
<ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li> <li>清理数据库中的过期键值对。</li> <li>对不合理的数据库进行大小调整。</li> <li>关闭和清理连接失效的客户端。</li> <li>尝试进行 AOF 或 RDB 持久化操作。</li> <li>如果服务器是主节点的话，对附属节点进行定期同步。</li> <li>如果处于集群模式的话，对集群进行定期同步和连接测试。</li></ul></li> <li>maxmemory</li> <li>当前已用内存超过maxmemory限定时，触发主动清理策略
<ul><li>volatile-lru：只对设置了过期时间的key进行LRU（默认值）</li> <li>allkeys-lru ： 删除lru算法的key</li> <li>volatile-random：随机删除即将过期key</li> <li>allkeys-random：随机删除</li> <li>volatile-ttl ： 删除即将过期的</li> <li>noeviction ： 永不过期，返回错误当mem_used内存已经超过maxmemory的设定</li></ul></li></ul></li> <li>redis 采用的过期策略</li> <li>惰性删除+定期删除</li> <li>4、RDB对过期key的处理</li></ul> <p>过期key对RDB没有任何影响</p> <ul><li>从内存数据库持久化数据到RDB文件
<ul><li>持久化key之前，会检查是否过期，过期的key不进入RDB文件</li></ul></li> <li>从RDB文件恢复数据到内存数据库
<ul><li>数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li></ul></li> <li>5、AOF对过期key的处理</li></ul> <p>过期key对AOF没有任何影响</p> <ul><li>从内存数据库持久化数据到AOF文件：
<ul><li>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）</li> <li>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</li></ul></li> <li>AOF重写
<ul><li>重写时，会先判断key是否过期，已过期的key不会重写到aof文件</li></ul></li></ul> <h3 id="最大内存淘汰策略"><a href="#最大内存淘汰策略" class="header-anchor">#</a> 最大内存淘汰策略</h3> <ul><li>maxmemory-policy</li> <li>volatile-lru</li> <li>OOM</li></ul> <h3 id="事务"><a href="#事务" class="header-anchor">#</a> 事务</h3> <p>Redis 通过 MULTI 、 DISCARD 、 EXEC和 WATCH 四个命令来实现事务功能</p> <ul><li><p>MULTI # 开启事务</p></li> <li><p>EXEC # 触发事务</p></li> <li><p>``` redis&gt; MULTI OK</p> <p>redis&gt; SET book-name &quot;Mastering C++ in 21 days&quot; QUEUED</p> <p>redis&gt; GET book-name QUEUED</p> <p>redis&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot; QUEUED</p> <p>redis&gt; SMEMBERS tag QUEUED</p> <p>redis&gt; EXEC 1) OK 2) &quot;Mastering C++ in 21 days&quot; 3) (integer) 3 4) 1) &quot;Mastering Series&quot; 2) &quot;C++&quot; 3) &quot;Programming&quot; ```</p></li> <li><p>事务执行过程</p></li> <li><p>开始事务。</p></li> <li><p>命令入队。</p></li> <li><p>执行事务。</p></li> <li><p>DISCARD</p></li> <li><p>用于取消一个事务,清空客户端的整个事务队列,然后将客户端从事务状态调整回非事务状态</p></li> <li><p>WATCH</p></li> <li><p>用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败</p></li></ul> <h3 id="pipeline-与事务"><a href="#pipeline-与事务" class="header-anchor">#</a> Pipeline 与事务</h3> <h4 id="_1-pipeline概念"><a href="#_1-pipeline概念" class="header-anchor">#</a> 1. Pipeline概念</h4> <p><code>Redis</code>客户端执行一条命令分为以下四个步骤:</p> <p>1.发送命令 2.命令排队 3.命令执行 4.返回结果</p> <p>其中,第一步+第四步称为<code>Round Trip Time</code>(<code>RTT</code>,往返时间).</p> <p><img src="https://segmentfault.com/img/bVV916?w=1372&amp;h=744" alt="图1.1 没有Pipeline执行n次命令"></p> <p><code>Redis</code>提供了批量操作命令(例如<code>mget</code>,<code>mset</code>等),有效的节约<code>RTT</code>.但大部分命令是不支持批量操作的,例如要执行<code>n</code>次<code>hgetall</code>命令,并没有<code>mhgetall</code>存在,需要消耗<code>n</code>次<code>RTT</code>.<code>Redis</code>的客户端和服务端可能不是在不同的机器上.例如客户端在北京,<code>Redis</code>服务端在上海,两地直线距离为1300公里,那么1次<code>RTT</code>时间=<code>1300×2/(300000×2/3)=13毫秒</code>(光在真空中传输速度为每秒30万公里,这里假设光纤的速度为光速的2/3),那么客户端在1秒内大约只能执行80次左右的命令,这个和<code>Redis</code>的高并发高吞吐背道而驰.</p> <p><code>Pipeline</code>(流水线)机制能改善上面这类问题,它能将一组<code>Redis</code>命令进行组装,通过一次<code>RTT</code>传输给<code>Redis</code>,再将这组<code>Redis</code>命令按照顺序执行并装填结果返回给客户端.<strong>图1.1</strong>中未使用<code>Pipeline</code>执行了n次命令,整个过程需要n个<code>RTT</code>.</p> <p><code>Pipeline</code>并不是什么新的技术和机制,很多技术上都使用过.而且<code>RTT</code>在不同网络环境下会有不同,例如同机房和同机器会比较快,跨机房跨地区会比较慢.<code>Redis</code>命令真正执行的时间通常在微秒级别,所以才会有<code>Redis</code>性能瓶颈是网络这样的说法.</p> <h4 id="_2-原生批量命令与pipeline对比"><a href="#_2-原生批量命令与pipeline对比" class="header-anchor">#</a> 2. 原生批量命令与Pipeline对比</h4> <p>可以使用<code>Pipeline</code>模拟出批量操作的效果,但是在使用时需要质疑它与原生批量命令的区别,具体包含几点:</p> <ul><li>原生批量命令是原子性,<code>Pipeline</code>是非原子性的.</li> <li>原生批量命令是一个命令对应多个<code>key</code>,<code>Pipeline</code>支持多个命令.</li> <li>原生批量命令是<code>Redis</code>服务端支持实现的,而<code>Pipeline</code>需要服务端与客户端的共同实现.</li></ul> <h4 id="_3-pipeline总结"><a href="#_3-pipeline总结" class="header-anchor">#</a> 3. Pipeline总结</h4> <p><code>Pipeline</code>虽然好用,但是每次<code>Pipeline</code>组装的命令个数不能没有节制,否则一次组装<code>Pipeline</code>数据量过大,一方面会增加客户端的等待时机,另一方面会造成一定的网络阻塞,可以将一次包含大量命令的<code>Pipeline</code>拆分成多次较小的<code>Pipeline</code>来完成.</p> <p><code>Pipeline</code>只能操作一个<code>Redis</code>实例,但即使在分布式<code>Redis</code>场景中,也可以作为批量操作的重要优化方法.</p> <h3 id="事务-2"><a href="#事务-2" class="header-anchor">#</a> 事务</h3> <p>为了保证多条命令组合的原子性,<code>Redis</code>提供了简单的事务以及集成<code>Lua</code>脚本来解决这个问题.</p> <p>熟悉关系型数据库的开发者应该对事务比较了解,简单地说,事务表示一组动作,要么全部成功,要不全部不成功.例如在在电商网站中<strong>用户</strong>购买<strong>商品A</strong>那么需要将<strong>商品A</strong>的库存-1,并创建一个订单.这两个操作要么远不执行成功,要么全部执行不成功,否则会出现数据不一致的情况.</p> <p><code>Redis</code>提供了简单的功能,将一组需要一起执行的命令放到<code>multi</code>和<code>exec</code>两个命令之间.<code>multi</code>命令代表事务的开始,<code>exec</code>命令代表事务结束,他们之间的命令是原子顺序执行的. 例如上述的用户购买商品问题:</p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; multi
    OK
    127.0.0.1:6379&gt; hincrby commodity:a:detail stock -1
    QUEUE
    127.0.0.1:6379&gt; rpush user:1:orders {&quot;commodity&quot;:'a',..}
    QUEUE
</code></pre></div><p>可以看到数据操作命令返回的结果是<code>QUEUE</code>,代表命令并没有真正执行,而是暂时保存在<code>Redis</code>中.如果此时另一个客户端执行<code>llen user:1:orders</code>返回结果为0.</p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; llen user:1:orders
    (integer) 0
</code></pre></div><p>只有当<code>exec</code>执行后,用户购买商品的行为才算完成,如下两个结果对应<code>hincrby</code>和<code>rpush</code>命令.</p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; exec
    1) (integer) 4  # 商品原库存为5
    2) (integer) 1
    127.0.0.1:6379&gt; llen user:1:orders
    (integer) 1
</code></pre></div><p>如果要停止事务的执行,可以使用<code>discard</code>命令替代<code>exec</code>命令即可.</p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; discard
    OK
    127.0.0.1:6379&gt; llen user:1:orders
    (integer) 0
</code></pre></div><p>如果事务中的命令出现错误,<code>Redis</code>的处理机制也不尽相同.</p> <p>1.<strong>命令错误</strong> 例如下面操作错将<code>set</code>写成了<code>sett</code>,属于语法错误,会造成整个事务无法执行,<code>key</code>和<code>counter</code>的值未发生变化:</p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; mget key counter
    1) &quot;hello&quot;
    2) &quot;100&quot;
    127.0.0.1:6379&gt; multi
    OK
    127.0.0.1:6379&gt; sett key world
    (error) ERR unknown command 'sett'
    127.0.0.1:6379&gt; incr counter
    QUEUE
    127.0.0.1:6379&gt; exec
    (error) EXECABORT Transaction discarded because of previous errors.
    127.0.0.1:6379&gt; mget key counter
    1) &quot;hello&quot;
    2) &quot;100&quot;
</code></pre></div><p>2.<strong>运行时错误</strong> 例如用户购买商品,误把<code>rpush</code>写成了<code>zadd</code></p> <div class="language- extra-class"><pre class="language-text"><code>    127.0.0.1:6379&gt; multi
    OK
    127.0.0.1:6379&gt; hincrby commodity:a:detail stock -1
    QUEUED
    127.0.0.1:6379&gt; zadd user:1:orders {&quot;commodity&quot;:'a',..}
    QUEUED
    127.0.0.1:6379&gt; exec
    1) (integer) 1
    2) (error) WRONGTYPE Operation against a key holding the wrong kind of value.
    127.0.0.1:6379&gt; hget commodity:a:detail stack
    (integer) 3
</code></pre></div><p>可以看到<code>Redis</code>并不支持回滚功能,<code>hincrby commodity:a:detail stock -1</code>命令已经执行成功,开发者需要自己修改这类问题.</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/Essay/assets/js/app.dc899fd4.js" defer></script><script src="/Essay/assets/js/2.b39f6721.js" defer></script><script src="/Essay/assets/js/19.0fba421d.js" defer></script>
  </body>
</html>
